import config from'./nf-indexedDB.config.js'const nfIndexedDB=()=>{const myDB=window.indexedDB||window.webkitIndexedDB||window.mozIndexedDB||window.msIndexedDB
if(!myDB){console.log('你的浏览器不支持IndexedDB')}let _db
const _vueToObject=(vueObject)=>{let _object=vueObject
if(Vue.isRef(_object)){_object=_object.value}if(Vue.isReactive(_object)){_object=Vue.toRaw(_object)}return _object}const dbOpen=(dbName,version)=>{const name=config.dbName||dbName
const ver=config.ver||version
const dbRequest=myDB.open(name,ver)let isChange=false
if(config.debug){console.log('dbRequest - 打开indexedDb数据库：',dbRequest)}const dbPromise=new Promise((resolve,reject)=>{dbRequest.onsuccess=(event)=>{_db=dbRequest.result
if(isChange){setup().then(()=>{resolve(_db)})}else{resolve(_db)}}dbRequest.onerror=(event)=>{reject(event)}})dbRequest.onupgradeneeded=function(event){isChange=true
_db=event.target.result
for(let i=0;i<config.objectStores.length;i++){const object=config.objectStores[i]if(!_db.objectStoreNames.contains(object.objectStoreName)){const objectStore=_db.createObjectStore(object.objectStoreName,{keyPath:'id'})for(let i=0;i<object.index.length;i++){const index=object.index[i]objectStore.createIndex(index.name,index.name,{unique:index.unique})}if(config.debug){console.log('onupgradeneeded - 建立了一个新的对象仓库：',objectStore)}}}}return dbPromise}const setup=()=>{const objectPromise=new Promise((resolve,reject)=>{const arrStore=[]for(const key in config.objects){arrStore.push(key)}if(config.debug){console.log('setup - arrStore',arrStore)}const tranRequest=_db.transaction(arrStore,'readwrite')for(const key in config.objects){const objectArror=config.objects[key]const store=tranRequest.objectStore(key)store.clear().onsuccess=(event)=>{for(let i=0;i<objectArror.length;i++){store.add(objectArror[i]).onsuccess=(event)=>{console.log(`添加成功！key:${key}-i:${i}`)}}}}tranRequest.oncomplete=(event)=>{if(config.debug){console.log('setup - oncomplete')}resolve()}tranRequest.onerror=function(event){reject(event)}})return objectPromise}const deleteStore=(storeName)=>{const objectPromise=new Promise((resolve,reject)=>{const _deleteStore=()=>{const tranRequest=_db.transaction(storeName,'readwrite')tranRequest.objectStore(storeName).delete().onsuccess=(event)=>{resolve(event)}tranRequest.onerror=function(event){reject(event)}}if(typeof _db==='undefined'){dbOpen().then(()=>{_deleteStore()})}else{_deleteStore()}})return objectPromise}const deleteDB=(dbName)=>{const objectPromise=new Promise((resolve,reject)=>{myDB.deleteDatabase(dbName).onsuccess=(event)=>{resolve(event)}})return objectPromise}const addObject=(objectName,object)=>{const _object=_vueToObject(object)const objectPromise=new Promise((resolve,reject)=>{const _addObject=()=>{const tranRequest=_db.transaction(objectName,'readwrite')tranRequest.objectStore(objectName).add(_object).onsuccess=(event)=>{resolve(event.target.result)}tranRequest.oncomplete=(event)=>{console.log('addObject -- oncomplete')}tranRequest.onerror=function(event){reject(event)}}if(typeof _db==='undefined'){dbOpen().then(()=>{_addObject()})}else{_addObject()}})return objectPromise}const updateObject=(objectName,object)=>{const _object=_vueToObject(object)const objectPromise=new Promise((resolve,reject)=>{const _updateObject=()=>{const tranRequest=_db.transaction(objectName,'readwrite')tranRequest.objectStore(objectName).get(_object.id).onsuccess=(event)=>{const newObject={...event.target.result,..._object}tranRequest.objectStore(objectName).put(newObject).onsuccess=(event)=>{console.log('updateObject -- onsuccess- event:',event)resolve(event.target.result)}}tranRequest.onerror=function(event){reject(event)}}if(typeof _db==='undefined'){dbOpen().then(()=>{_updateObject()})}else{_updateObject()}})return objectPromise}const deleteObject=(objectName,id)=>{const objectPromise=new Promise((resolve,reject)=>{const _deleteObject=()=>{const tranRequest=_db.transaction(objectName,'readwrite')tranRequest.objectStore(objectName).delete(id).onsuccess=(event)=>{resolve(event.target.result)}tranRequest.onerror=function(event){reject(event)}}if(typeof _db==='undefined'){dbOpen().then(()=>{_deleteObject()})}else{_deleteObject()}})return objectPromise}const clearStore=(storeName)=>{const objectPromise=new Promise((resolve,reject)=>{const _clearStore=()=>{const tranRequest=_db.transaction(storeName,'readwrite')tranRequest.objectStore(storeName).clear().onsuccess=(event)=>{resolve(event)}tranRequest.onerror=function(event){reject(event)}}if(typeof _db==='undefined'){dbOpen().then(()=>{_clearStore()})}else{_clearStore()}})return objectPromise}const getObject=(objectName,id)=>{const objectPromise=new Promise((resolve,reject)=>{const _getObject=()=>{const tranRequest=_db.transaction(objectName,'readonly')if(typeof id==='undefined'){tranRequest.objectStore(objectName).getAll().onsuccess=(event)=>{console.log('getObject -- onsuccess- event:',event)resolve(event.target.result)}}else{tranRequest.objectStore(objectName).get(id).onsuccess=(event)=>{console.log('getObject -- onsuccess- event:',event)resolve(event.target.result)}}tranRequest.oncomplete=(event)=>{console.log('getObject -- oncomplete')}tranRequest.onerror=function(event){reject(event)}}if(typeof _db==='undefined'){dbOpen().then(()=>{_getObject()})}else{_getObject()}})return objectPromise}const findObjectByStore=(objectName,count,start,description)=>{const _start=start||0
const _count=count||0
const _end=_start+_count
const _description=description||'prev'console.log('getObjectByStore-db:',_db)console.log(`_start:${_start}-_count:${_count}-_end:${_end}`)const objectPromise=new Promise((resolve,reject)=>{const _getObjectByStore=()=>{const dataList=[]let cursorIndex=0
console.log('getObjectByStore-db22:',_db)const tranRequest=_db.transaction(objectName,'readonly')const cursorRequest=tranRequest.objectStore(objectName).openCursor(null,_description)cursorRequest.onsuccess=(event)=>{var cursor=event.target.result
if(cursor){if(_end===0||(cursorIndex>=_start&&cursorIndex<_end)){dataList.push(cursor.value)console.log(cursorIndex)}cursorIndex++cursor.continue()}else{}}tranRequest.oncomplete=(event)=>{console.log('getObjectByStore -- oncomplete')resolve(dataList)}tranRequest.onerror=function(event){reject(event)}}if(typeof _db==='undefined'){dbOpen().then(()=>{_getObjectByStore()})}else{_getObjectByStore()}})return objectPromise}const findObjectByIndex=(objectName,indexName,id,page={},where)=>{const _start=page.start||0
const _count=page.count||0
const _end=_start+_count
const _description=page.description||IDBCursor.prev
const keyRange=IDBKeyRange.only(id)console.log('findObjectByIndex - keyRange',keyRange)const objectPromise=new Promise((resolve,reject)=>{const _findObjectByIndex=()=>{const dataList=[]let cursorIndex=0
const tranRequest=_db.transaction(objectName,'readonly')const cursorRequest=tranRequest.objectStore(objectName).index(indexName).openCursor(keyRange,_description)cursorRequest.onsuccess=(event)=>{console.log('findObjectByIndex - onsuccess - event',event)const cursor=event.target.result
if(cursor){if(_end===0||(cursorIndex>=_start&&cursorIndex<_end)){if(typeof where==='function'){if(where(cursor.value,cursorIndex)){dataList.push(cursor.value)cursorIndex++}}else{dataList.push(cursor.value)cursorIndex++}}cursor.continue()}}tranRequest.oncomplete=(event)=>{console.log('findObjectByIndex - dataList',dataList)resolve(dataList)}tranRequest.onerror=function(event){console.log('findObjectByIndex - onerror',event)reject(event)}}if(typeof _db==='undefined'){dbOpen().then(()=>{_findObjectByIndex()})}else{_findObjectByIndex()}})return objectPromise}return{dbOpen,setup,addObject,updateObject,deleteObject,getObject,findObjectByStore,findObjectByIndex,clearStore,deleteStore,deleteDB}}export default nfIndexedDB